<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wptherml.em &mdash; wptherml  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            wptherml
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">wptherml</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wptherml.em</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wptherml.em</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.spectrum_driver</span> <span class="kn">import</span> <span class="n">SpectrumDriver</span>
<span class="kn">from</span> <span class="nn">.materials</span> <span class="kn">import</span> <span class="n">Materials</span>
<span class="kn">from</span> <span class="nn">.therml</span> <span class="kn">import</span> <span class="n">Therml</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Circle</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cmx</span>
<span class="kn">from</span> <span class="nn">scipy.linalg.blas</span> <span class="kn">import</span> <span class="n">zgemm</span>  <span class="c1"># BLAS-optimized complex matrix multiplication</span>


<span class="c1">#@jit(nopython=True)</span>
<span class="k">def</span> <span class="nf">_compute_dm</span><span class="p">(</span><span class="n">refractive_index</span><span class="p">,</span> <span class="n">cosine_theta</span><span class="p">,</span> <span class="n">polarization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the D and D_inv matrices for each layer and wavelength&quot;&quot;&quot;</span>
    <span class="n">_dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">refractive_index</span> <span class="o">*</span> <span class="n">cosine_theta</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">refractive_index</span> <span class="o">*</span> <span class="n">cosine_theta</span>

    <span class="k">elif</span> <span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosine_theta</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosine_theta</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">refractive_index</span>
        <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">refractive_index</span>

    <span class="c1"># Faster manual inversion of 2x2 matrix</span>
    <span class="n">_det</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_det</span> <span class="o">*</span> <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">_det</span> <span class="o">*</span> <span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">_det</span> <span class="o">*</span> <span class="n">_dm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_det</span> <span class="o">*</span> <span class="n">_dm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">_dm</span><span class="p">,</span> <span class="n">_dim</span>


<span class="k">def</span> <span class="nf">_compute_pm</span><span class="p">(</span><span class="n">phil</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the P matrices for each intermediate layer and wavelength&quot;&quot;&quot;</span>
    <span class="n">_pm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>  <span class="c1"># Identity matrix to avoid unnecessary zeros</span>
    <span class="n">_ci</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span>  <span class="c1"># Directly use imaginary unit</span>

    <span class="n">_pm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">_ci</span> <span class="o">*</span> <span class="n">phil</span><span class="p">)</span>
    <span class="n">_pm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_ci</span> <span class="o">*</span> <span class="n">phil</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_pm</span>

<span class="c1">#@jit(nopython=True)</span>
<span class="k">def</span> <span class="nf">_compute_pm_analytical_gradient</span><span class="p">(</span><span class="n">kzl</span><span class="p">,</span> <span class="n">phil</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;compute the derivative of the P matrix with respect to layer thickness</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">        kzl : complex float</span>
<span class="sd">            the z-component of the wavevector in layer l</span>
<span class="sd">        phil : complex float</span>
<span class="sd">            kzl * sl where sl is the thickness of layer l</span>
<span class="sd">    Reference</span>
<span class="sd">    ---------</span>
<span class="sd">        Equation 18 of https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.2.013018</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        _pm_analytical_gradient : 2x2 numpy array of complex floats</span>
<span class="sd">            the analytical derivative of the P matrix with respect to thickness of layer l</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pm_analytical_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">_ci</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span>
    <span class="n">_a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">_ci</span> <span class="o">*</span> <span class="n">phil</span>
    <span class="n">_b</span> <span class="o">=</span> <span class="n">_ci</span> <span class="o">*</span> <span class="n">phil</span>

    <span class="n">_pm_analytical_gradient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">_ci</span> <span class="o">*</span> <span class="n">kzl</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span>
    <span class="n">_pm_analytical_gradient</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ci</span> <span class="o">*</span> <span class="n">kzl</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_pm_analytical_gradient</span>


<div class="viewcode-block" id="TmmDriver">
<a class="viewcode-back" href="../../autosummary/wptherml.TmmDriver.html#wptherml.TmmDriver">[docs]</a>
<span class="k">class</span> <span class="nc">TmmDriver</span><span class="p">(</span><span class="n">SpectrumDriver</span><span class="p">,</span> <span class="n">Materials</span><span class="p">,</span> <span class="n">Therml</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collects methods for computing the reflectivity, absorptivity/emissivity, and transmissivity</span>
<span class="sd">       of multilayer structures using the Transfer Matrix Method.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    number_of_layers : int</span>
<span class="sd">        the number of layers in the multilayer</span>
<span class="sd">    number_of_wavelengths : int</span>
<span class="sd">        the number of wavelengths in the wavelength_array</span>
<span class="sd">    thickness_array : 1 x number_of_layers numpy array of floats</span>
<span class="sd">        the thickness of each layer</span>
<span class="sd">    material_array : 1 x number_of_layers numpy array of str</span>
<span class="sd">        the materia of each layer</span>
<span class="sd">    wavelength_array : numpy array of floats</span>
<span class="sd">        the array of wavelengths in meters over which you will compute the spectra</span>
<span class="sd">    incident_angle : float</span>
<span class="sd">        the incident angle of light relative to the normal to the multilayer (0 = normal incidence!)</span>
<span class="sd">    polarization : str</span>
<span class="sd">        indicates if incident light is &#39;s&#39; or &#39;p&#39; polarized</span>
<span class="sd">    reflectivity_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">        the reflection spectrum</span>
<span class="sd">    transmissivity_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">        the transmission spectrum</span>
<span class="sd">    emissivity_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">        the absorptivity / emissivity spectrum</span>
<span class="sd">    _refractive_index_array : number_of_layers x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">        the array of refractive index values corresponding to wavelength_array</span>
<span class="sd">    _tm : 2 x 2 x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">        the transfer matrix for each wavelength</span>
<span class="sd">    _kz_array : 1 x number_lf_layers x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">        the z-component of the wavevector in each layer of the multilayer for each wavelength</span>
<span class="sd">    _k0_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">        the wavevector magnitude in the incident layer for each wavelength</span>
<span class="sd">    _kx_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">        the x-component of the wavevector for each wavelength (conserved throughout layers)</span>
<span class="sd">    _pm : 2 x 2 x (number_of_layers-2) x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">        the P matrix for each of the finite-thickness layers for each wavelength</span>
<span class="sd">    _dm : 2 x 2 x number_of_layers x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">        the D matrix for each of the layers for each wavelength</span>
<span class="sd">    _dim : 2 x 2 x number_of_layers x number_of_wavelengts numpy array of complex floats</span>
<span class="sd">        the inverse of the D matrix for each of the layers for each wavelength</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TmmDriver.__init__">
<a class="viewcode-back" href="../../autosummary/wptherml.TmmDriver.html#wptherml.TmmDriver.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;constructor for the TmmDriver class</span>
<span class="sd">        Assign values for attributes thickness_array, material_array then call</span>
<span class="sd">        compute_spectrum to compute values for attributes reflectivity_array,</span>
<span class="sd">        transmissivity_array, and emissivity_array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure all keys are lowercase only</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># parse user inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parse_input</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># set refractive index array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_refractive_index_array</span><span class="p">()</span>
        <span class="c1"># compute reflectivity spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>

        <span class="c1"># print output message</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Your spectra have been computed! </span><span class="se">\N{smiling face with sunglasses}</span><span class="s2"> &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;therml&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_therml_input</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_therml_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_power_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_stpv_power_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_stpv_spectral_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_luminous_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Your therml spectra have been computed! </span><span class="se">\N{fire}</span><span class="s2"> &quot;</span><span class="p">)</span>

        <span class="c1"># treat cooling specially because we need emissivity at lots of angles!</span>
        <span class="k">if</span> <span class="s2">&quot;cooling&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_therml_input</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># get \epsilon_s(\lambda, \theta) and \epsilon_s(\lambda, \theta) for thermal radiation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_explicit_angle_spectrum</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot; Your angle-dependent spectra have been computed! </span><span class="se">\N{smiling face with sunglasses}</span><span class="s2"> &quot;</span>
            <span class="p">)</span>

            <span class="c1"># call _compute_thermal_radiated_power( ) function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radiative_cooling_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_thermal_radiated_power</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_s</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_p</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># call _compute_atmospheric_radiated_power() function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atmospheric_warming_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_atmospheric_radiated_power</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_atmospheric_transmissivity</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_s</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_p</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># need to get one more set of \epsilon_s(\lambda, solar_angle) and \epsilon_p(\lamnda, solar_angle)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
            <span class="n">solar_absorptivity_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
            <span class="n">solar_absorptivity_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solar_warming_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solar_radiated_power</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span><span class="p">,</span>
                <span class="n">solar_absorptivity_s</span><span class="p">,</span>
                <span class="n">solar_absorptivity_p</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_cooling_power</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">radiative_cooling_power</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmospheric_warming_power</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_warming_power</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot; Your radiative cooling quantities have been computed! </span><span class="se">\N{smiling face with sunglasses}</span><span class="s2"> &quot;</span>
            <span class="p">)</span></div>


            <span class="c1"># call _compute_solar_radiated_power() function</span>

    <span class="k">def</span> <span class="nf">parse_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;method to parse the user inputs and define structures / simulation</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;incident_angle&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="c1"># user input expected in deg so convert to radians</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;incident_angle&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="s2">&quot;polarization&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;polarization&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;wavelength_list&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">lamlist</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;wavelength_list&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lamlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">lamlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lamlist</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavenumber_array</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>
        <span class="c1"># default wavelength array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">400e-9</span><span class="p">,</span> <span class="mf">800e-9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavenumber_array</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>

        <span class="c1"># need to throw some exceptions if len(self.thickness_array)!=len(self.material_array)</span>
        <span class="k">if</span> <span class="s2">&quot;thickness_list&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;thickness_list&quot;</span><span class="p">])</span>
        <span class="c1"># default structure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Thickness array not specified!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Proceeding with default structure - optically thick W! &quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">900e-9</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="s2">&quot;material_list&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material_array</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;material_list&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">material_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Material array not specified!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Proceeding with default structure - Air / SiO2 / Air &quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material_array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Air&quot;</span><span class="p">,</span> <span class="s2">&quot;SiO2&quot;</span><span class="p">,</span> <span class="s2">&quot;Air&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">=</span> <span class="mi">3</span>
            
        <span class="c1"># see if we want to specify certain layers to randomize the thickness of</span>
        <span class="k">if</span> <span class="s2">&quot;random_thickness_layers&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_thickness_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;random_thickness_layers&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># default is that all layers can be randomized in thickness</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_thickness_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>

        <span class="c1"># do we want to put bounds on the random thicknesses (specified in nanometers)</span>
        <span class="k">if</span> <span class="s2">&quot;random_thickness_bounds_nm&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;random_thickness_bounds&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimum_thickness_nm</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum_thickness_nm</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># default to 1 nm for minimum and 1000 nm for maximum</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimum_thickness_nm</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum_thickness_nm</span> <span class="o">=</span> <span class="mi">1000</span>

        <span class="c1"># see if we want to specifiy only certain layers with materials</span>
        <span class="c1"># that can be randomized</span>
        <span class="k">if</span> <span class="s2">&quot;random_material_layers&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_materials_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">args</span><span class="p">[</span><span class="s2">&quot;random_material_layers&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>

        <span class="c1"># default is that all layers can be randomized</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_materials_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>

        <span class="c1"># see if there are specific materials we would like to draw from</span>
        <span class="k">if</span> <span class="s2">&quot;possible_random_materials&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possible_materials</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;possible_random_materials&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># default materials to draw from</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">possible_materials</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SiO2&quot;</span><span class="p">,</span> <span class="s2">&quot;Al2O3&quot;</span><span class="p">,</span> <span class="s2">&quot;TiO2&quot;</span><span class="p">,</span> <span class="s2">&quot;Ag&quot;</span><span class="p">,</span> <span class="s2">&quot;Au&quot;</span><span class="p">,</span> <span class="s2">&quot;Ta2O5&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;transmission_efficiency_weight&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found transmission efficiency weight (TEW) arg&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_weight</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;transmission_efficiency_weight&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_weight</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">F</span><span class="s1">&#39;TEW is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_weight</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="s2">&quot;reflection_efficiency_weight&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_weight</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;reflection_efficiency_weight&quot;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found reflection efficiency weight (REW) arg&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_weight</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">F</span><span class="s1">&#39;REW is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_weight</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;reflection_selectivity_weight&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found reflection selectivity weight (RSW) arg&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_weight</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;reflection_selectivity_weight&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_weight</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">F</span><span class="s1">&#39;RSW is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_weight</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>



        <span class="n">_tot_weight</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_weight</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">_tot_weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_weight</span> <span class="o">/=</span> <span class="n">_tot_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_weight</span> <span class="o">/=</span> <span class="n">_tot_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_weight</span> <span class="o">/=</span> <span class="n">_tot_weight</span>

        <span class="c1"># user can specify which layers to compute gradients with respect to</span>
        <span class="c1"># i.e. for a structure like [&#39;Air&#39;, &#39;SiO2&#39;, &#39;Ag&#39;, &#39;TiO2&#39;, &#39;Air]</span>
        <span class="c1"># the gradient list [1, 2] would take the gradients</span>
        <span class="c1"># with respect to layer 1 (top-most SiO2) and layer 2 (silver) only, while</span>
        <span class="c1"># leaving out layer 3 (TiO2)</span>
        <span class="k">if</span> <span class="s2">&quot;gradient_list&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradient_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;gradient_list&quot;</span><span class="p">])</span>
        <span class="c1"># default is all layers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gradient_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>

        <span class="c1"># if we specify a number of angles to compute the spectra over</span>
        <span class="c1"># this only gets used if we need explicit inclusion of angle of incidence/emission</span>
        <span class="c1"># for a given quantity</span>
        <span class="k">if</span> <span class="s2">&quot;number_of_angles&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;number_of_angles&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this is a good default empirically if</span>
            <span class="c1"># Gauss-Legendre quadrature is used for angular spectra</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span> <span class="o">=</span> <span class="mi">7</span>
            
        <span class="c1"># some keywords for the visible transmissive and IR reflective Stacks for Blake and Michael</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s2">&quot;transmissive_window_nm&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">lamlist</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;transmissive_window_nm&quot;</span><span class="p">]</span>
            <span class="c1"># in nanometers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_start_nm</span> <span class="o">=</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_stop_nm</span> <span class="o">=</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># in SI units</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_start</span> <span class="o">=</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-9</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_stop</span> <span class="o">=</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-9</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># default to visible</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_start</span> <span class="o">=</span> <span class="mf">350e-9</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_stop</span> <span class="o">=</span> <span class="mf">700e-9</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_start</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_window_stop</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_envelope</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="s2">&quot;reflective_window_wn&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">lamlist</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;reflective_window_wn&quot;</span><span class="p">]</span>
            <span class="c1"># in inverse cm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_start_wn</span> <span class="o">=</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_stop_wn</span> <span class="o">=</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># in SI units</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_start</span> <span class="o">=</span> <span class="mi">10000000</span> <span class="o">/</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-9</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_stop</span> <span class="o">=</span> <span class="mi">10000000</span> <span class="o">/</span> <span class="n">lamlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-9</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># default to 2000 - 2400 wavenumbers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_start_wn</span> <span class="o">=</span> <span class="mi">2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_stop_wn</span> <span class="o">=</span> <span class="mi">2400</span>
            <span class="c1"># in SI units</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_start</span> <span class="o">=</span> <span class="mi">10000000</span> <span class="o">/</span> <span class="mi">2400</span> <span class="o">*</span> <span class="mf">1e-9</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_stop</span> <span class="o">=</span> <span class="mi">10000000</span> <span class="o">/</span> <span class="mi">2000</span> <span class="o">*</span> <span class="mf">1e-9</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_start</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflective_window_stop</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Retrieve psc thickness for _EQE_spectral_response</span>
        <span class="k">if</span> <span class="s2">&quot;psc_thickness_option&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psc_thickness_option</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;psc_thickness_option&quot;</span><span class="p">]</span>
        <span class="c1"># default to 200</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psc_thickness_option</span> <span class="o">=</span> <span class="mi">200</span>

        <span class="k">if</span> <span class="s2">&quot;pv_lambda_bandgap&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pv_lambda_bandgap</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;pv_lambda_bandgap&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pv_lambda_bandgap</span> <span class="o">=</span> <span class="mf">750e-9</span>
            
        <span class="c1"># for now always get solar spectrum!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_AM</span><span class="p">()</span>

        <span class="c1"># for now always get atmospheric transmissivity spectru</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atmospheric_transmissivity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_Atmospheric_Transmissivity</span><span class="p">()</span>

        

    <span class="k">def</span> <span class="nf">set_refractive_index_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;once materials are specified, define the refractive_index_array values&quot;&quot;&quot;</span>

        <span class="c1"># initialize _ri_list based on the number of layers</span>
        <span class="n">_ri_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># initialize the _refractive_index_array with dummy values define the true values later!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">_ri_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># terminal layers default to air for now... generalize later!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_Air</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_Air</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># get lower clase version of the material string</span>
            <span class="c1"># to avoid any conflicts with variation in cases</span>
            <span class="c1"># given by the user</span>
            <span class="n">_lm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="c1"># keep the original string too in case it is a file name</span>
            <span class="n">_original_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># check all possible values of the material string</span>
            <span class="c1"># and set material as appropriate.</span>
            <span class="c1"># in future probably good to create a single wrapper</span>
            <span class="c1"># function in materials.py that will do this so</span>
            <span class="c1"># that MieDriver and TmmDriver can just use it rather</span>
            <span class="c1"># than duplicating this kind of code in both classes</span>
            <span class="k">if</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;air&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Air</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;ag&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Ag</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;al&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Al</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;al2o3&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Al2O3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;al2o3_udm&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Al2O3_UDM</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;aln&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_AlN</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;au&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Au</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;hfo2&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_HfO2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;hfo2_udm&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_HfO2_UDM</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">#&lt;== from this source http://newad.physics.muni.cz/table-udm/HfO2-X2194-AO54_9108.Enk - recommended for ALD HfO2</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;hfo2_udm_no_loss&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_HfO2_UDM_v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">#&lt;== from this source http://newad.physics.muni.cz/table-udm/HfO2-X2194-AO54_9108.Enk but k set to 0.0</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;mgf2&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_MgF2_UDM</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">#&lt;== from this source http://newad.physics.muni.cz/table-udm/MgF2-X2935-SPIE9628.Enk - recommended for ALD MgF2</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;pb&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Pb</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;polystyrene&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_polystyrene</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;pt&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Pt</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;re&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Re</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;rh&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Rh</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;ru&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Ru</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;si&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Si</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;sio2&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_SiO2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;sio2_udm&quot;</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">material_SiO2_UDM</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;sio2_udm_v2&quot;</span><span class="p">:</span> <span class="c1">#&lt;== from this source http://newad.physics.muni.cz/table-udm/LithosilQ2-SPIE9890.Enk - recommended for ALD SiO2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_SiO2_UDM_v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;ta2o5&quot;</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">material_Ta2O5</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;tin&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_TiN</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;tio2&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_TiO2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_W</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;zro2&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_ZrO2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_lm</span> <span class="o">==</span> <span class="s2">&quot;si3n4&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_Si3N4</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># if we don&#39;t match one of these strings, then we assume the user has passed</span>
            <span class="c1"># a filename</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_from_file</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_original_string</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reverse the order of the stack</span>
<span class="sd">        e.g. if you have a structure that is Air/SiO2/HfO2/Ag/Air</span>
<span class="sd">        and you issue reverse_stack, the new structrure will be</span>
<span class="sd">        Air/Ag/HfO2/SiO2/Air</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store temporary versions of the RI array and thickness array</span>
        <span class="n">_ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span>
        <span class="n">_ta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span>

        <span class="c1"># use np.flip to reverse the arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">_ri</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">_ta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_number</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;remove layer number layer_number from your stack.</span>
<span class="sd">        e.g. if you have a structure that is Air/SiO2/HfO2/Ag/Air</span>
<span class="sd">        and you issue remove_layer(2), the new structrure will be</span>
<span class="sd">        Air/SiO2/Ag/Air</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">_nwl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">_nl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">_temp_ri_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">)</span>
        <span class="n">_temp_thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">)</span>

        <span class="n">_new_ri_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nwl</span><span class="p">,</span> <span class="n">_nl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">_new_thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_nl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">_new_ri_array</span><span class="p">[:,</span> <span class="p">:</span><span class="n">layer_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">_temp_ri_array</span><span class="p">[:,</span> <span class="p">:</span><span class="n">layer_number</span><span class="p">]</span>
        <span class="n">_new_thickness_array</span><span class="p">[:</span><span class="n">layer_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">_temp_thickness_array</span><span class="p">[:</span><span class="n">layer_number</span><span class="p">]</span>

        <span class="n">_new_ri_array</span><span class="p">[:,</span> <span class="n">layer_number</span><span class="p">:]</span> <span class="o">=</span> <span class="n">_temp_ri_array</span><span class="p">[:,</span> <span class="n">layer_number</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="n">_new_thickness_array</span><span class="p">[</span><span class="n">layer_number</span><span class="p">:]</span> <span class="o">=</span> <span class="n">_temp_thickness_array</span><span class="p">[</span><span class="n">layer_number</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">_new_ri_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">_new_thickness_array</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_number</span><span class="p">,</span> <span class="n">layer_thickness</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;insert an air layer between layer_number-1 and layer_number</span>
<span class="sd">        e.g. if you have a structure that is Air/SiO2/HfO2/Ag/Air</span>
<span class="sd">        and you issue insert_layer(1), the new structure will be</span>
<span class="sd">        Air/Air/SiO2/HfO2/Ag/Air</span>
<span class="sd">        if you issue insert_layer(2), the new structure will be</span>
<span class="sd">        Air/SiO2/Air/HfO2/Ag/Air</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">_nwl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">_nl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">_temp_ri_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">)</span>
        <span class="n">_temp_thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">)</span>

        <span class="n">_new_ri_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nwl</span><span class="p">,</span> <span class="n">_nl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">_new_thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_nl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">_new_air_layer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_nwl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>

        <span class="n">_new_ri_array</span><span class="p">[:,</span> <span class="p">:</span><span class="n">layer_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">_temp_ri_array</span><span class="p">[:,</span> <span class="p">:</span><span class="n">layer_number</span><span class="p">]</span>
        <span class="n">_new_thickness_array</span><span class="p">[:</span><span class="n">layer_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">_temp_thickness_array</span><span class="p">[:</span><span class="n">layer_number</span><span class="p">]</span>

        <span class="n">_new_ri_array</span><span class="p">[:,</span> <span class="n">layer_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">_new_air_layer</span>
        <span class="n">_new_thickness_array</span><span class="p">[</span><span class="n">layer_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer_thickness</span>

        <span class="n">_new_ri_array</span><span class="p">[:,</span> <span class="n">layer_number</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_temp_ri_array</span><span class="p">[:,</span> <span class="n">layer_number</span><span class="p">:]</span>
        <span class="n">_new_thickness_array</span><span class="p">[</span><span class="n">layer_number</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_temp_thickness_array</span><span class="p">[</span><span class="n">layer_number</span><span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">_new_ri_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">_new_thickness_array</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot; A &quot;</span><span class="p">,</span>
            <span class="n">layer_thickness</span><span class="p">,</span>
            <span class="s2">&quot; m air layer has been inserted into layer numbe &quot;</span><span class="p">,</span>
            <span class="n">layer_number</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot; Use the `material_X(&quot;</span><span class="p">,</span>
            <span class="n">layer_number</span><span class="p">,</span>
            <span class="s2">&quot;) command to define the material of this new layer!&quot;</span><span class="p">,</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">randomize_thickness_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to randomize the thickness array&quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_thickness_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_thickness_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">_d</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_thickness_nm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum_thickness_nm</span><span class="p">)</span>
                <span class="o">*</span> <span class="mf">1e-9</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_d</span>

    <span class="k">def</span> <span class="nf">randomize_materials_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to randomize the materials array&quot;&quot;&quot;</span>
        <span class="c1"># randomize the materials array</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_materials_list</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">possible_materials</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials_code</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_materials_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">_jdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material_array</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">possible_materials</span><span class="p">[</span><span class="n">_jdx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">materials_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_jdx</span>

        <span class="c1"># reset the refractive index array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_refractive_index_array</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compute_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;computes the following attributes:</span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        reflectivity_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the reflectivity spectrum</span>
<span class="sd">        transmissivity_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the transmissivity spectrum</span>
<span class="sd">        emissivity_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the absorptivity / emissivity spectrum</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># with all of these formed, you can now call _compute_tm()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_k0</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kx</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kz</span><span class="p">()</span>

        <span class="c1"># compute the reflectivity in a loop for now!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">):</span>
            <span class="n">_k0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k0_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">_ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">_kz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kz_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># get transfer matrix, theta_array, and co_theta_array for current k0 value</span>
            <span class="n">_tm</span><span class="p">,</span> <span class="n">_theta_array</span><span class="p">,</span> <span class="n">_cos_theta_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm</span><span class="p">(</span>
                <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span>
            <span class="p">)</span>

            <span class="c1"># if self.gradient==True:</span>
            <span class="c1">#    _tmg = self._compute_tm_grad(_ri, _k0, _kz, self.thickness_array)</span>

            <span class="c1"># reflection amplitude</span>
            <span class="n">_r</span> <span class="o">=</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># transmission amplitude</span>
            <span class="n">_t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># refraction angle and RI prefractor for computing transmission</span>
            <span class="n">_factor</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_ri</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">_ri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="c1"># reflectivity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_r</span><span class="p">))</span>

            <span class="c1"># transmissivity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">_t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">_factor</span><span class="p">)</span>

            <span class="c1"># emissivity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="c1"># self.render_color(&quot;ambient color&quot;)</span>

    <span class="k">def</span> <span class="nf">compute_explicit_angle_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;computes the following attributes:</span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        reflectivity_array_s : N_deg x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the reflectivity spectrum vs wavelength and angle with s-polarization</span>
<span class="sd">        reflectivity_array_p : N_deg x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the reflectivity spectrum vs wavelength and angle with p-polarization</span>

<span class="sd">        transmissivity_array_s : N_deg x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the transmissivity spectrum vs wavelength and angle with s-polarization</span>
<span class="sd">        transmissivity_array_p : N_deg x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the transmissivity spectrum vs wavelength and angle with p-polarization</span>

<span class="sd">        emissivity_array_s : N_deg x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the emissivity spectrum vs wavelength and angle with s-polarization</span>
<span class="sd">        emissivity_array_p : N_deg x number_of_wavelengths numpy array of floats</span>
<span class="sd">            the emissivity spectrum vs wavelength and angle with p-polarization</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize the angle-dependent arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># now set up the angular Gauss-Legendre grid</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggauss</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>

        <span class="c1"># compute k0 which does not care about angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_k0</span><span class="p">()</span>

        <span class="c1"># loop over angles first</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># compute kx and kz, which do depend on angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kx</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kz</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_wavelengths</span><span class="p">):</span>
                <span class="n">_k0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k0_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">_ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">_kz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kz_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># get transfer matrix, theta_array, and co_theta_array for current k0 value and &#39;s&#39; polarization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
                <span class="n">_tm_s</span><span class="p">,</span> <span class="n">_theta_array_s</span><span class="p">,</span> <span class="n">_cos_theta_array_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm</span><span class="p">(</span>
                    <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span>
                <span class="p">)</span>

                <span class="c1"># get transfer matrix, theta_array, and cos_theta_array for current k0 value and &#39;p&#39; polarization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
                <span class="n">_tm_p</span><span class="p">,</span> <span class="n">_theta_array_p</span><span class="p">,</span> <span class="n">_cos_theta_array_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm</span><span class="p">(</span>
                    <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span>
                <span class="p">)</span>

                <span class="c1"># reflection amplitude</span>
                <span class="n">_r_s</span> <span class="o">=</span> <span class="n">_tm_s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm_s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">_r_p</span> <span class="o">=</span> <span class="n">_tm_p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm_p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># transmission amplitude</span>
                <span class="n">_t_s</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_tm_s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">_t_p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_tm_p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># refraction angle and RI prefractor for computing transmission</span>
                <span class="n">_factor_s</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_ri</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="o">*</span> <span class="n">_cos_theta_array_s</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="o">/</span> <span class="p">(</span><span class="n">_ri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_cos_theta_array_s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">_factor_p</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_ri</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="o">*</span> <span class="n">_cos_theta_array_p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="o">/</span> <span class="p">(</span><span class="n">_ri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_cos_theta_array_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">)</span>

                <span class="c1"># reflectivity</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array_s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">_r_s</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_r_s</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array_p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">_r_p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_r_p</span><span class="p">))</span>

                <span class="c1"># transmissivity</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array_s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                    <span class="n">_t_s</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_t_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">_factor_s</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array_p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                    <span class="n">_t_p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">_t_p</span><span class="p">)</span> <span class="o">*</span> <span class="n">_factor_p</span>
                <span class="p">)</span>

                <span class="c1"># emissivity</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">1</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array_s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array_s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">1</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array_p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array_p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_spectrum_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;computes the following attributes:</span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        reflectivity_gradient_array : number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the reflectivity spectrum</span>
<span class="sd">        transmissivity_gradient_array : number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the transmissivity spectrum</span>
<span class="sd">        emissivity_gradient_array : number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the absorptivity / emissivity spectrum</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize gradient arrays</span>
        <span class="c1"># _nwl -&gt; number of wavelengths</span>
        <span class="n">_nwl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="c1"># _ngr -&gt; number of gradient dimensions</span>
        <span class="n">_ngr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradient_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">):</span>
                <span class="n">_k0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k0_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">_ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">_kz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kz_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># get transfer matrix, theta_array, and co_theta_array for current k0 value</span>
                <span class="n">_tm</span><span class="p">,</span> <span class="n">_theta_array</span><span class="p">,</span> <span class="n">_cos_theta_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm</span><span class="p">(</span>
                    <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span>
                <span class="p">)</span>

                <span class="c1"># get gradient of transfer matrix with respect to layer i</span>
                <span class="n">_tm_grad</span><span class="p">,</span> <span class="n">_theta_array</span><span class="p">,</span> <span class="n">_cos_theta_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm_gradient</span><span class="p">(</span>
                    <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>

                <span class="c1"># Using equation (14) from https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.013018</span>
                <span class="c1"># for the derivative of the reflection amplitude for wavelength j with respect to layer i</span>
                <span class="c1"># from wptherml: r_prime = (M11*M21p[j] - M21*M11p[j])/(M11*M11)</span>
                <span class="n">r_prime</span> <span class="o">=</span> <span class="p">(</span><span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_tm_grad</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_tm_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span>
                <span class="c1"># using equation (12) to get the reflection amplitude at wavelength j</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Using equation (10) to get the derivative of R at waveleength j with respect to layer i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                    <span class="n">r_prime</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">r_prime</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># compute t_prime using equation (15)</span>
                <span class="n">t_prime</span> <span class="o">=</span> <span class="o">-</span><span class="n">_tm_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># compute t using equation equation (13)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="n">_factor</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_ri</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="o">/</span> <span class="p">(</span><span class="n">_ri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">)</span>

                <span class="c1"># compute the derivative of T at wavelength j with respect to layer i using Eq. (11)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">t_prime</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t_prime</span><span class="p">))</span> <span class="o">*</span> <span class="n">_factor</span>
                <span class="p">)</span>
                <span class="c1"># derivative of \epsilon is - \partial R / \partial s -\partial T / \partial s</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_explicit_angle_spectrum_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;computes the following attributes:</span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        reflectivity_gradient_array_s : N_deg x number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the gradient of the s-polarized reflectivity spectrum vs angle</span>

<span class="sd">        reflectivity_gradient_array_p : N_deg x number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the gradient of the p-polarized reflectivity spectrum vs angle</span>

<span class="sd">        transmissivity_gradient_array_s : N_deg x number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the grdient of the s-polarized transmissivity spectrum vs angle</span>

<span class="sd">        transmissivity_gradient_array_p : N_deg x number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the grdient of the p-polarized transmissivity spectrum vs angle</span>

<span class="sd">        emissivity_gradient_array_s : N_deg x number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the grdient of the s-polarized emissivity spectrum vs angle</span>

<span class="sd">        emissivity_gradient_array_p : N_deg x number_of_wavelengths x len(gradient_list) numpy array of floats</span>
<span class="sd">            the grdient of the p-polarized emissivity spectrum vs angle</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize gradient arrays</span>
        <span class="c1"># _nwl -&gt; number of wavelengths</span>
        <span class="n">_nwl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="c1"># _ngr -&gt; number of gradient dimensions</span>
        <span class="n">_ngr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradient_list</span><span class="p">)</span>
        <span class="c1"># _nth -&gt; number of angles</span>
        <span class="n">_nth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_angles</span>

        <span class="c1"># jjf note - _nwl is going to be the longest axis in most cases</span>
        <span class="c1"># should it be either the inner-most or outter-most dimension instead for</span>
        <span class="c1"># performance reasons?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nth</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nth</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nth</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nth</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nth</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">_nth</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">))</span>

        <span class="c1"># compute k0 which does not care about angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_k0</span><span class="p">()</span>

        <span class="c1"># loop over angles first</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_nth</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="c1"># compute kx and kz, which do depend on angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kx</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kz</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_ngr</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_nwl</span><span class="p">):</span>
                    <span class="n">_k0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k0_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">_ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">_kz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kz_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="c1"># s-polarization first</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
                    <span class="c1"># get transfer matrix, theta_array, and co_theta_array for current k0 value</span>
                    <span class="n">_tm</span><span class="p">,</span> <span class="n">_theta_array</span><span class="p">,</span> <span class="n">_cos_theta_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm</span><span class="p">(</span>
                        <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span>
                    <span class="p">)</span>

                    <span class="c1"># get gradient of transfer matrix with respect to layer i</span>
                    <span class="p">(</span>
                        <span class="n">_tm_grad</span><span class="p">,</span>
                        <span class="n">_theta_array</span><span class="p">,</span>
                        <span class="n">_cos_theta_array</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm_gradient</span><span class="p">(</span>
                        <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="c1"># Using equation (14) from https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.013018</span>
                    <span class="c1"># for the derivative of the reflection amplitude for wavelength j with respect to layer i</span>
                    <span class="c1"># from wptherml: r_prime = (M11*M21p[j] - M21*M11p[j])/(M11*M11)</span>
                    <span class="n">r_prime</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_tm_grad</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_tm_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="c1"># using equation (12) to get the reflection amplitude at wavelength j</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Using equation (10) to get the derivative of R at waveleength j with respect to layer i</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array_s</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                        <span class="n">r_prime</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">r_prime</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># compute t_prime using equation (15)</span>
                    <span class="n">t_prime</span> <span class="o">=</span> <span class="o">-</span><span class="n">_tm_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                    <span class="c1"># compute t using equation equation (13)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                    <span class="n">_factor</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">_ri</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="o">/</span> <span class="p">(</span><span class="n">_ri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="p">)</span>

                    <span class="c1"># compute the derivative of T at wavelength j with respect to layer i using Eq. (11)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array_s</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">t_prime</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t_prime</span><span class="p">))</span> <span class="o">*</span> <span class="n">_factor</span>
                    <span class="p">)</span>
                    <span class="c1"># derivative of \epsilon is - \partial R / \partial s -\partial T / \partial s</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_s</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array_s</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array_s</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="c1"># p-polarization second</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
                    <span class="c1"># get transfer matrix, theta_array, and co_theta_array for current k0 value</span>
                    <span class="n">_tm</span><span class="p">,</span> <span class="n">_theta_array</span><span class="p">,</span> <span class="n">_cos_theta_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm</span><span class="p">(</span>
                        <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span>
                    <span class="p">)</span>

                    <span class="c1"># get gradient of transfer matrix with respect to layer i</span>
                    <span class="p">(</span>
                        <span class="n">_tm_grad</span><span class="p">,</span>
                        <span class="n">_theta_array</span><span class="p">,</span>
                        <span class="n">_cos_theta_array</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_tm_gradient</span><span class="p">(</span>
                        <span class="n">_ri</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="c1"># Using equation (14) from https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.013018</span>
                    <span class="c1"># for the derivative of the reflection amplitude for wavelength j with respect to layer i</span>
                    <span class="c1"># from wptherml: r_prime = (M11*M21p[j] - M21*M11p[j])/(M11*M11)</span>
                    <span class="n">r_prime</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_tm_grad</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_tm_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="c1"># using equation (12) to get the reflection amplitude at wavelength j</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Using equation (10) to get the derivative of R at waveleength j with respect to layer i</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array_p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                        <span class="n">r_prime</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">r_prime</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># compute t_prime using equation (15)</span>
                    <span class="n">t_prime</span> <span class="o">=</span> <span class="o">-</span><span class="n">_tm_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                    <span class="c1"># compute t using equation equation (13)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_tm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                    <span class="n">_factor</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">_ri</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="o">/</span> <span class="p">(</span><span class="n">_ri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">_cos_theta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="p">)</span>

                    <span class="c1"># compute the derivative of T at wavelength j with respect to layer i using Eq. (11)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array_p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">t_prime</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t_prime</span><span class="p">))</span> <span class="o">*</span> <span class="n">_factor</span>
                    <span class="p">)</span>
                    <span class="c1"># derivative of \epsilon is - \partial R / \partial s -\partial T / \partial s</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array_p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array_p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_stpv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compute the figures of merit for STPV applications, including&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_therml_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_power_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_stpv_power_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_stpv_spectral_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_stpv_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum_gradient</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_therml_spectrum_gradient</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_power_density_gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_stpv_power_density_gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_stpv_spectral_efficiency_gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_pv_stpv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A method to compute the different figures of merit for PV-STPV, which </span>
<span class="sd">        should follow a similar pattern as compute_stpv() on line 944</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first compute or set temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_self_consistent_temperature</span><span class="p">()</span>

        <span class="c1"># second compute short circuit current</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_pv_stpv_short_circuit_current</span><span class="p">()</span>

        <span class="c1"># third compute splitting power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_pv_stpv_splitting_power</span><span class="p">()</span>
        <span class="c1"># probably JSCself._compute_pv_stpv_power_density(self.wavelength_array)</span>

    <span class="k">def</span> <span class="nf">compute_pv_stpv_short_circuit_current</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to compute the f_C figure of merit for pv-stpv, Eq. (45) here: https://www.overleaf.com/project/648a0cfeae29e31e10afc075</span>
<span class="sd">        We will assume the base layer is the AR + Polystyrene stack so we</span>
<span class="sd">        will add the PSC layer here too</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First make sure we have full stack including the PSC layer</span>
        <span class="c1"># get terminal layer number</span>
        <span class="n">_ln</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># insert thick active layer as the bottom-most layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_layer</span><span class="p">(</span><span class="n">_ln</span><span class="p">,</span> <span class="mf">1000e-9</span><span class="p">)</span>
        <span class="c1"># make sure the active layer has RI of 2D perovskite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_2D_HOIP</span><span class="p">(</span><span class="n">_ln</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="n">absorptivity_full_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>

        <span class="c1"># get envelope function that behaves like ideal spectral response function</span>
        <span class="n">bg_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_lambda_bandgap</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="c1"># scale AM by \lambda / \lambda_bg</span>
        <span class="n">env</span><span class="p">[:</span><span class="n">bg_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">[:</span><span class="n">bg_idx</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_lambda_bandgap</span>
        <span class="c1"># compute the useful power density spectrum</span>
        <span class="n">power_density_array</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span> <span class="o">*</span> <span class="n">absorptivity_full_stack</span> <span class="o">*</span> <span class="n">env</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pv_stpv_short_circuit_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
            <span class="n">power_density_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>
        <span class="p">)</span>

        <span class="c1"># go back to original spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="n">_ln</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="n">emissivity_1_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>
        <span class="c1"># get Blackbody spectrum at the default temperature - this is tentative</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_therml_spectrum</span><span class="p">()</span>

        <span class="c1"># now add perovskite layer to the stack and get the emissivity/absorptivity towards the sky</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_stack</span><span class="p">()</span>


        


    <span class="k">def</span> <span class="nf">compute_pv_stpv_short_circuit_current_gradient_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the following attributes for short circuit current calculation:</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>

<span class="sd">        e_gradient_index : Integer</span>
<span class="sd">                        Length of the emissivity gradient array.</span>

<span class="sd">        emissivity_gradient_array_prime : Array</span>
<span class="sd">                                        (Emissivity gradient array x Wavelength array) / Lambda bandgap.</span>

<span class="sd">        pv_stpv_short_circuit_current : Float</span>
<span class="sd">                                    Short circuit current as defined in Equation (23) of https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.013018</span>
<span class="sd">                                     the integration of Emissivity x Spectral Response x Solar Spectrum over wavelength.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Looking at the short circuit current (Jsc)</span>
        <span class="c1"># Need to iterate over emissivity_gradient_array for every value at a given wavelength.</span>
        <span class="c1"># Need to take the integral of this multiplied by _solar_spectrum and spectral_response (both precalculated), between 0 and lambda bandgap.</span>


        <span class="n">_ln</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thickness_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># insert thick active layer as the bottom-most layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_layer</span><span class="p">(</span><span class="n">_ln</span><span class="p">,</span> <span class="mf">1000e-9</span><span class="p">)</span>
        <span class="c1"># make sure the active layer has RI of 2D perovskite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_2D_HOIP</span><span class="p">(</span><span class="n">_ln</span><span class="p">)</span>
        <span class="c1"># Acquire necessary variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_AM</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="n">absorptivity_2_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>

        <span class="c1"># get the absorbed power</span>
        <span class="n">P_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">absorptivity_2_T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="c1"># loop over temperature to try to find the temperature of the stack that balances emitted</span>
        <span class="c1"># power with absorbed power</span>
        <span class="n">_kill</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">_kill</span><span class="p">:</span>
            <span class="n">_T</span> <span class="o">=</span> <span class="mi">300</span>
            <span class="n">_bbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_blackbody_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span> <span class="n">_T</span><span class="p">)</span>
            <span class="n">P_emit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_bbs</span> <span class="o">*</span> <span class="p">(</span><span class="n">emissivity_1_B</span> <span class="o">+</span> <span class="n">emissivity_1_T</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_T</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">P_emit</span> <span class="o">&gt;</span> <span class="n">P_abs</span><span class="p">:</span>
                <span class="n">_kill</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_pv_stpv_power_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="c1"># reverse stack again and add active layer and get absorbed power into the structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum_gradient</span><span class="p">()</span>

        <span class="c1"># Initialize short circuit current array</span>
        <span class="n">e_gradient_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pv_stpv_short_circuit_current_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">e_gradient_index</span><span class="p">)</span>

        <span class="n">bg_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_lambda_bandgap</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">_spectral_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="n">_spectral_response</span><span class="p">[:</span><span class="n">bg_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">[:</span><span class="n">bg_idx</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_lambda_bandgap</span>

        <span class="c1"># Iterate over material thicknesses</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">e_gradient_index</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pv_stpv_short_circuit_current_gradient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">_spectral_response</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># Integrate for short circuit current</span>

        <span class="c1"># go back to original spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="n">_ln</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum_gradient</span><span class="p">()</span>
    <span class="c1"># Other figure of merit calculations here to be called in compute_pv_stpv</span>

    <span class="k">def</span> <span class="nf">compute_pv_stpv_total_incident_power</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Docstring</span>
<span class="sd">        Use equation npv = Jsc * Voc * FF</span>
<span class="sd">        Jsc = short circuit current</span>
<span class="sd">        Voc = open circuit current</span>
<span class="sd">        FF = fill factor/ratio of ontainable power to short circuit * open circuit voltage</span>
<span class="sd">        </span>
<span class="sd">        The plan:</span>

<span class="sd">        initialze npv (assuming a static number), calculate Voc and FF, and multiply these three together to get total incident power as a unitless efficiency </span>
<span class="sd">        Voc = (kB*Temperature/charge)*(ln(short circuit current)/(initial current))</span>
<span class="sd">        total_incident_power = pv_stpv_short_circuit_current_gradient * Voc * Fill factor</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span> 
    
    <span class="k">def</span> <span class="nf">compute_pv_stpv_splitting_power_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">        Docstring</span>

<span class="sd">        Method to compute the pv_stpv splitting power spectrum as defined by </span>
<span class="sd">         the integrand of Eq. (46) of https://www.overleaf.com/project/648a0cfeae29e31e10afc075 </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># reverse the stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_stack</span><span class="p">()</span>
        <span class="c1"># update emissivity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
               
    
        <span class="c1"># Store thermal emission spectra into the active layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pv_stpv_splitting_power_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blackbody_spectrum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>

        <span class="c1"># reverse the stack back</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_stack</span><span class="p">()</span>
        <span class="c1"># update the spectra for the normal direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>

        <span class="c1"># approximate ideal spectral response assuming \lambda_bg = 700 nm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_bandgap</span> <span class="o">=</span> <span class="mf">700e-9</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_bandgap</span>
        <span class="c1"># make sure we have the solar spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_AM</span><span class="p">()</span>
        <span class="c1"># now compute pv_stpv short circuit current</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_pv_short_circuit_current</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_response</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span><span class="p">,</span>
        <span class="p">)</span>


    <span class="k">def</span> <span class="nf">compute_pv_stpv_splitting_power</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">        Docstring</span>

<span class="sd">        Method to compute the pv_stpv splitting power as defined in Eq. (46) of https://www.overleaf.com/project/648a0cfeae29e31e10afc075 </span>
<span class="sd">        Attributes</span>
<span class="sd">        -----------</span>
<span class="sd">        emissivity_AR_polystyrene : array</span>
<span class="sd">                                    Storage of emissivity array.</span>
<span class="sd">        sliced_wavelength_array : array</span>
<span class="sd">                                    Slice of the wavelength array over the upper and lower limits determined by the minimum and maximum</span>
<span class="sd">                                    differences of array values and the integral&#39;s bounds.</span>
<span class="sd">        sliced_emissivity_array : array</span>
<span class="sd">                                    Slice of the emissivity array over the upper and lower limits determined by the minimum and maximum</span>
<span class="sd">                                    differences of array values and the integral&#39;s bounds.</span>
<span class="sd">        pv_stpv_splitting_power : array</span>
<span class="sd">                                    Emissivity array integrated over 3.0 to 3.5 microns.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Notes:  The emissivity needs to be computed for the reversed original stack (meaning the stack *without the active layer*) before updating the </span>
<span class="sd">                thermal emission spectrum.</span>
<span class="sd">                Steps:</span>
<span class="sd">                1. Reverse the stack</span>
<span class="sd">                2. Compute the optical spectra</span>
<span class="sd">                3. Compute the thermal emission spectra</span>
<span class="sd">                4. Define the integrand in Eq. (46)</span>
<span class="sd">                5. Integrate the integrand and store to the attribute self.pv_stpv_splitting_power</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
               
        <span class="c1"># Reverse stack, active layer was removed in the last function</span>
        <span class="c1"># Compute the optical and thermal spectra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_pv_stpv_splitting_power_spectrum</span><span class="p">()</span>

        <span class="c1"># Set integration limits to lambda 1 to lambda 2 (3 um and 3.5 um) and store</span>
        <span class="n">x_lower_limit</span> <span class="o">=</span> <span class="mf">3e-6</span>
        <span class="n">x_upper_limit</span> <span class="o">=</span> <span class="mf">3.5e-6</span>

        <span class="c1"># Subtracts the limit from the original arrays, apply absolute value, and finds the minimum or maximum point</span>
        <span class="n">wavelength_array_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> <span class="o">-</span> <span class="n">x_lower_limit</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">wavelength_array_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> <span class="o">-</span> <span class="n">x_upper_limit</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        
        <span class="n">sliced_wavelength_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">[</span><span class="n">wavelength_array_lower</span><span class="p">:</span><span class="n">wavelength_array_upper</span><span class="p">]</span>
        <span class="n">sliced_splitting_spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_stpv_splitting_power_spectrum</span><span class="p">[</span><span class="n">wavelength_array_lower</span><span class="p">:</span><span class="n">wavelength_array_upper</span><span class="p">]</span>

        <span class="c1"># Integrate over these slices and store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pv_stpv_splitting_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">sliced_splitting_spectrum</span><span class="p">,</span> <span class="n">sliced_wavelength_array</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">compute_self_consistent_temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to compute the self-consistent temperature that balances emitted with absorbed power</span>
<span class="sd">        for pv-stpv applications</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this loops over temperatures starting with 300 K and stops when emitted power exceeds</span>
        <span class="c1"># absorbed power.</span>
        <span class="c1"># TO DO:</span>
        <span class="c1"># need to make sure we are computing the correct values of emissivity using the notes above</span>
        <span class="n">_kill</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_T</span> <span class="o">=</span> <span class="mi">300</span>

        <span class="c1">#while(_kill):</span>
        <span class="c1">#    _bbs = self._compute_blackbody_spectrum(self.wavelength_array, _T)</span>
        <span class="c1">#    P_emit = np.trapz( np.pi/2 * _bbs * (emissivity_A_B + absorptivity_AB_T), self.wavelength_array)</span>
        <span class="c1">#    _T += 1</span>
        <span class="c1">#    if P_emit &gt; absorptivity_B_T :</span>
        <span class="c1">#        _kill = 0</span>
        <span class="c1"># assign _T to self.temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">_T</span>


        
    <span class="k">def</span> <span class="nf">compute_cooling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to compute the radiative cooling figures of merit</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.radiative_cooling_power : float</span>
<span class="sd">            the thermal power radiated by a structure into the universe (P_rad)</span>

<span class="sd">        self.atmospheric_warming_power : float</span>
<span class="sd">            the thermal power radiated by the atmosphere and absorbed by a structure (P_atm)</span>

<span class="sd">        self.solar_warming_power : float</span>
<span class="sd">            the thermal power radiated by the sun and absorbed by a structure (P_sun)</span>

<span class="sd">        self.net_cooling_power : float</span>
<span class="sd">            P_rad - P_atm - P_sum ... if positive, the structure is net cooling if negative, it is net heating</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get \epsilon_s(\lambda, \theta) and \epsilon_s(\lambda, \theta) for thermal radiation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_explicit_angle_spectrum</span><span class="p">()</span>

        <span class="c1"># call _compute_thermal_radiated_power( ) function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radiative_cooling_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_thermal_radiated_power</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_s</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_p</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># call _compute_atmospheric_radiated_power() function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atmospheric_warming_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_atmospheric_radiated_power</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_atmospheric_transmissivity</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_s</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array_p</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># need to get one more set of \epsilon_s(\lambda, solar_angle) and \epsilon_p(\lamnda, solar_angle)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="n">solar_absorptivity_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="n">solar_absorptivity_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_warming_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solar_radiated_power</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span><span class="p">,</span>
            <span class="n">solar_absorptivity_s</span><span class="p">,</span>
            <span class="n">solar_absorptivity_p</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net_cooling_power</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radiative_cooling_power</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_warming_power</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmospheric_warming_power</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_cooling_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># get the gradient of the emissivity vs angle and wavelength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_explicit_angle_spectrum_gradient</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radiative_cooling_power_gradient</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_thermal_radiated_power_gradient</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_s</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_p</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atmospheric_warming_power_gradient</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_atmospheric_radiated_power_gradient</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_atmospheric_transmissivity</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_s</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array_p</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_vals</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_weights</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># need to get one more set of \epsilon_s(\lambda, solar_angle) and \epsilon_p(\lamnda, solar_angle)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum_gradient</span><span class="p">()</span>
        <span class="n">solar_absorptivity_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum_gradient</span><span class="p">()</span>
        <span class="n">solar_absorptivity_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emissivity_gradient_array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solar_warming_power_gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_solar_radiated_power_gradient</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solar_spectrum</span><span class="p">,</span>
            <span class="n">solar_absorptivity_s</span><span class="p">,</span>
            <span class="n">solar_absorptivity_p</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net_cooling_power_gradient</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radiative_cooling_power_gradient</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_warming_power_gradient</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atmospheric_warming_power_gradient</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_kz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;computes the z-component of the wavevector in each layer of the stack</span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            _refractive_index_array : number_of_wavelength x number_of_layers numpy array of complex floats</span>
<span class="sd">                the array of refractive index values corresponding to wavelength_array</span>
<span class="sd">            _kz_array : number_of_wavelength x number_of_layers numpy array of complex floats</span>
<span class="sd">                the z-component of the wavevector in each layer of the multilayer for each wavelength</span>
<span class="sd">            _kx_array : 1 x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">                the x-component of the wavevector in each layer for each wavelength</span>
<span class="sd">            _k0_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">                the wavevector magnitude in the incident layer for each wavelength</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kz_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k0_array</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kx_array</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_k0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;computes the _k0_array</span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            wavelength_array : 1 x number of wavelengths float</span>
<span class="sd">                the wavelengths that will illuminate the structure in SI units</span>
<span class="sd">            _k0_array : 1 x number of wavelengths float</span>
<span class="sd">                the wavenumbers that will illuminate the structure in SI units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k0_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>

    <span class="k">def</span> <span class="nf">_compute_kx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;computes the _kx_array</span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">            _refractive_index_array : number_of_layers x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">                the array of refractive index values corresponding to wavelength_array</span>
<span class="sd">            incident_angle : float</span>
<span class="sd">                the angle of incidence of light illuminating the structure</span>
<span class="sd">            _kx_array : 1 x number_of_wavelengths numpy array of complex floats</span>
<span class="sd">                the x-component of the wavevector in each layer for each wavelength</span>
<span class="sd">            _k0_array : 1 x number_of_wavelengths numpy array of floats</span>
<span class="sd">                the wavevector magnitude in the incident layer for each wavelengthhe wavenumbers that will illuminate the structure in SI units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute kx_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kx_array</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refractive_index_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span><span class="p">)</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k0_array</span>
        <span class="p">)</span>

    <span class="c1">#def _compute_tm_gradient(self, _refractive_index, _k0, _kz, _d, _ln):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;compute the transfer matrix for each wavelength</span>
<span class="sd">        _ln : int</span>
<span class="sd">            specifies the layer number the gradient will be taken with respect to</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _tm_gradient : 2 x 2 complex numpy array</span>
<span class="sd">            transfer matrix for the _k0 value</span>
<span class="sd">        _THETA : 1 x number_of_layers complex numpy array</span>
<span class="sd">            refraction angles in each layer for the _k0 value</span>
<span class="sd">        _CTHETA : 1 x number_of_layers complex numpy array</span>
<span class="sd">            cosine of the refraction angles in each layer for the _k0 value</span>
<span class="sd">        JJF Note: Basically the only difference between the calculation</span>
<span class="sd">        of the dM/dS_ln and M is that a single P matrix corresponding</span>
<span class="sd">        to _ln is replaced by dP/DP_ln.  So, you can basically modify the</span>
<span class="sd">        loop where _PM is computed to have a conditional that</span>
<span class="sd">        computes _PM by calling _compute_pm_gradient instead of _compute_pm</span>
<span class="sd">        when i == _ln</span>
<span class="sd">        </span>

<span class="sd">        _DM = np.zeros((2, 2, self.number_of_layers), dtype=complex)</span>
<span class="sd">        _DIM = np.zeros((2, 2, self.number_of_layers), dtype=complex)</span>
<span class="sd">        _PM = np.zeros((2, 2, self.number_of_layers), dtype=complex)</span>
<span class="sd">        _CTHETA = np.zeros(self.number_of_layers, dtype=complex)</span>
<span class="sd">        _THETA = np.zeros(self.number_of_layers, dtype=complex)</span>

<span class="sd">        _PHIL = _kz * _d</span>
<span class="sd">        _THETA[0] = self.incident_angle</span>
<span class="sd">        _CTHETA[0] = np.cos(self.incident_angle)</span>

<span class="sd">        _CTHETA[1 : self.number_of_layers] = _kz[1 : self.number_of_layers] / (</span>
<span class="sd">            _refractive_index[1 : self.number_of_layers] * _k0</span>
<span class="sd">        )</span>
<span class="sd">        _THETA[1 : self.number_of_layers] = np.arccos(</span>
<span class="sd">            _CTHETA[1 : self.number_of_layers]</span>
<span class="sd">        )</span>
<span class="sd">        # initialize _tm_gradient here!  (was previously _tm)</span>
<span class="sd">        _DM[:, :, 0], _tm_gradient = self._compute_dm(_refractive_index[0], _CTHETA[0])</span>

<span class="sd">        for i in range(1, self.number_of_layers - 1):</span>
<span class="sd">            _DM[:, :, i], _DIM[:, :, i] = self._compute_dm(</span>
<span class="sd">                _refractive_index[i], _CTHETA[i]</span>
<span class="sd">            )</span>
<span class="sd">            if i == _ln:</span>
<span class="sd">                _PM[:, :, i] = self._compute_pm_analytical_gradient(_kz[i], _PHIL[i])</span>
<span class="sd">            else:</span>
<span class="sd">                _PM[:, :, i] = self._compute_pm(_PHIL[i])</span>

<span class="sd">            _tm_gradient = np.matmul(_tm_gradient, _DM[:, :, i])</span>
<span class="sd">            _tm_gradient = np.matmul(_tm_gradient, _PM[:, :, i])</span>
<span class="sd">            _tm_gradient = np.matmul(_tm_gradient, _DIM[:, :, i])</span>

<span class="sd">        (</span>
<span class="sd">            _DM[:, :, self.number_of_layers - 1],</span>
<span class="sd">            _DIM[:, :, self.number_of_layers - 1],</span>
<span class="sd">        ) = self._compute_dm(</span>
<span class="sd">            _refractive_index[self.number_of_layers - 1],</span>
<span class="sd">            _CTHETA[self.number_of_layers - 1],</span>
<span class="sd">        )</span>

<span class="sd">        _tm_gradient = np.matmul(_tm_gradient, _DM[:, :, self.number_of_layers - 1])</span>

<span class="sd">        return _tm_gradient, _THETA, _CTHETA &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">_compute_tm_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_refractive_index</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="n">_d</span><span class="p">,</span> <span class="n">_ln</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the transfer matrix gradient with respect to a layer _ln&quot;&quot;&quot;</span>
        <span class="n">num_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span>

        <span class="n">_PHIL</span> <span class="o">=</span> <span class="n">_kz</span> <span class="o">*</span> <span class="n">_d</span>
        <span class="n">_THETA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_layers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">_CTHETA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_layers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

        <span class="c1"># Compute refraction angles</span>
        <span class="n">_THETA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span>
        <span class="n">_CTHETA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span><span class="p">)</span>
        <span class="n">_CTHETA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">_kz</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">_k0</span><span class="p">)</span>
        <span class="n">_THETA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">_CTHETA</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Initialize transfer matrix</span>
        <span class="n">_DM</span><span class="p">,</span> <span class="n">_tm_gradient</span> <span class="o">=</span> <span class="n">_compute_dm</span><span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_CTHETA</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>

        <span class="c1"># Loop through layers</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_DM</span><span class="p">,</span> <span class="n">_DIM</span> <span class="o">=</span> <span class="n">_compute_dm</span><span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_CTHETA</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">_ln</span><span class="p">:</span>
                <span class="n">_PM</span> <span class="o">=</span> <span class="n">_compute_pm_analytical_gradient</span><span class="p">(</span><span class="n">_kz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_PHIL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_PM</span> <span class="o">=</span> <span class="n">_compute_pm</span><span class="p">(</span><span class="n">_PHIL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Use BLAS-optimized multiplications</span>
            <span class="n">_tm_gradient</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm_gradient</span><span class="p">,</span> <span class="n">_DM</span><span class="p">)</span>
            <span class="n">_tm_gradient</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm_gradient</span><span class="p">,</span> <span class="n">_PM</span><span class="p">)</span>
            <span class="n">_tm_gradient</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm_gradient</span><span class="p">,</span> <span class="n">_DIM</span><span class="p">)</span>

        <span class="c1"># Compute last layer contribution</span>
        <span class="n">_DM</span><span class="p">,</span> <span class="n">_DIM</span> <span class="o">=</span> <span class="n">_compute_dm</span><span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_CTHETA</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>
        <span class="n">_tm_gradient</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm_gradient</span><span class="p">,</span> <span class="n">_DM</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_tm_gradient</span><span class="p">,</span> <span class="n">_THETA</span><span class="p">,</span> <span class="n">_CTHETA</span>


    <span class="k">def</span> <span class="nf">_compute_tm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_refractive_index</span><span class="p">,</span> <span class="n">_k0</span><span class="p">,</span> <span class="n">_kz</span><span class="p">,</span> <span class="n">_d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the transfer matrix for each wavelength&quot;&quot;&quot;</span>
        <span class="n">_PHIL</span> <span class="o">=</span> <span class="n">_kz</span> <span class="o">*</span> <span class="n">_d</span>
        <span class="n">_THETA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">_CTHETA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># Compute refraction angles</span>
        <span class="n">_THETA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span>
        <span class="n">_CTHETA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incident_angle</span><span class="p">)</span>
        <span class="n">_CTHETA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">_kz</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">_k0</span><span class="p">)</span>
        <span class="n">_THETA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">_CTHETA</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Initialize matrices</span>
        <span class="n">_DM</span><span class="p">,</span> <span class="n">_tm</span> <span class="o">=</span> <span class="n">_compute_dm</span><span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_CTHETA</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>

        <span class="c1"># Loop through layers (optimized)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_DM</span><span class="p">,</span> <span class="n">_DIM</span> <span class="o">=</span> <span class="n">_compute_dm</span><span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_CTHETA</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>
            <span class="n">_PM</span> <span class="o">=</span> <span class="n">_compute_pm</span><span class="p">(</span><span class="n">_PHIL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Use BLAS-optimized multiplication</span>
            <span class="n">_tm</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm</span><span class="p">,</span> <span class="n">_DM</span><span class="p">)</span>  <span class="c1"># In-place multiplication</span>
            <span class="n">_tm</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm</span><span class="p">,</span> <span class="n">_PM</span><span class="p">)</span>
            <span class="n">_tm</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm</span><span class="p">,</span> <span class="n">_DIM</span><span class="p">)</span>

        <span class="c1"># Last layer computation</span>
        <span class="n">_DM</span><span class="p">,</span> <span class="n">_DIM</span> <span class="o">=</span> <span class="n">_compute_dm</span><span class="p">(</span><span class="n">_refractive_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_CTHETA</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>
        <span class="n">_tm</span> <span class="o">=</span> <span class="n">zgemm</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">_tm</span><span class="p">,</span> <span class="n">_DM</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_tm</span><span class="p">,</span> <span class="n">_THETA</span><span class="p">,</span> <span class="n">_CTHETA</span> 
    
    <span class="k">def</span> <span class="nf">_compute_rgb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colorblindness</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">):</span>
        <span class="c1"># get color response functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_CIE</span><span class="p">()</span>
        <span class="c1"># plt.plot(self.wavelength_array * 1e9, self.reflectivity_array, label=&quot;Reflectivity&quot;)</span>
        <span class="c1"># plt.plot(self.wavelength_array * 1e9, self._cie_cr, label=&quot;CIE Red&quot;)</span>
        <span class="c1"># plt.legend()</span>
        <span class="c1"># plt.plot(self.wavelength_array, self._cie_cr * self.reflectivity_array)</span>
        <span class="c1"># plt.show()</span>

        <span class="c1"># get X, Y, and Z from reflectivity spectrum and Cr, Cg, Cb response functions</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cie_cr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cie_cg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cie_cb</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="c1"># zero out appropriate response if colorblindness is indicated</span>
        <span class="c1"># from here: https://www.color-blindness.com/types-of-color-blindness/</span>
        <span class="c1"># Tritanopia/Tritanomaly: Missing/malfunctioning S-cone (blue).</span>
        <span class="c1"># Deuteranopia/Deuteranomaly: Missing/malfunctioning M-cone (green).</span>
        <span class="c1"># Protanopia/Protanomaly: Missing/malfunctioning L-cone (red).</span>

        <span class="k">if</span> <span class="n">colorblindness</span> <span class="o">==</span> <span class="s2">&quot;Tritanopia&quot;</span> <span class="ow">or</span> <span class="n">colorblindness</span> <span class="o">==</span> <span class="s2">&quot;Tritanomaly&quot;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">colorblindness</span> <span class="o">==</span> <span class="s2">&quot;Deuteranopia&quot;</span> <span class="ow">or</span> <span class="n">colorblindness</span> <span class="o">==</span> <span class="s2">&quot;Deuteranomaly&quot;</span><span class="p">:</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">colorblindness</span> <span class="o">==</span> <span class="s2">&quot;Protanopia&quot;</span> <span class="ow">or</span> <span class="n">colorblindness</span> <span class="o">==</span> <span class="s2">&quot;Protanomaly&quot;</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># get total magnitude</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">+</span> <span class="n">Z</span>

        <span class="c1"># get normalized values</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">tot</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">/</span> <span class="n">tot</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">/</span> <span class="n">tot</span>

        <span class="c1"># should also be equal to z = 1 - x - y</span>
        <span class="c1"># array of xr, xg, xb, xw, ..., zr, zg, zb, zw</span>
        <span class="c1"># use hdtv standard</span>
        <span class="n">xrgbw</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.670</span><span class="p">,</span> <span class="mf">0.210</span><span class="p">,</span> <span class="mf">0.150</span><span class="p">,</span> <span class="mf">0.3127</span><span class="p">]</span>
        <span class="n">yrgbw</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.330</span><span class="p">,</span> <span class="mf">0.710</span><span class="p">,</span> <span class="mf">0.060</span><span class="p">,</span> <span class="mf">0.3291</span><span class="p">]</span>
        <span class="n">zrgbw</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xrgbw</span><span class="p">)):</span>
            <span class="n">zrgbw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">xrgbw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">yrgbw</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1">## rx = yg*zb - yb*zg</span>
        <span class="n">rx</span> <span class="o">=</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">## ry = xb*zg - xg*zb</span>
        <span class="n">ry</span> <span class="o">=</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1">## rz = (xg * yb) - (xb * yg)</span>
        <span class="n">rz</span> <span class="o">=</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">## gx = (yb * zr) - (yr * zb)</span>
        <span class="n">gx</span> <span class="o">=</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1">## gy = (xr * zb) - (xb * zr)</span>
        <span class="n">gy</span> <span class="o">=</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">## gz = (xb * yr) - (xr * yb)</span>
        <span class="n">gz</span> <span class="o">=</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1">## bx = (yr * zg) - (yg * zr)</span>
        <span class="n">bx</span> <span class="o">=</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">## by = (xg * zr) - (xr * zg)</span>
        <span class="n">by</span> <span class="o">=</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">## bz = (xr * yg) - (xg * yr)</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">## rw = ((rx * xw) + (ry * yw) + (rz * zw)) / yw;</span>
        <span class="n">rw</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx</span> <span class="o">*</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">ry</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">rz</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1">## gw = ((gx * xw) + (gy * yw) + (gz * zw)) / yw;</span>
        <span class="n">gw</span> <span class="o">=</span> <span class="p">(</span><span class="n">gx</span> <span class="o">*</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">gy</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">gz</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1">## bw = ((bx * xw) + (by * yw) + (bz * zw)) / yw;</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="p">(</span><span class="n">bx</span> <span class="o">*</span> <span class="n">xrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">by</span> <span class="o">*</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">bz</span> <span class="o">*</span> <span class="n">zrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">yrgbw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1">## /* xyz -&gt; rgb matrix, correctly scaled to white. */</span>
        <span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">/</span> <span class="n">rw</span>
        <span class="n">ry</span> <span class="o">=</span> <span class="n">ry</span> <span class="o">/</span> <span class="n">rw</span>
        <span class="n">rz</span> <span class="o">=</span> <span class="n">rz</span> <span class="o">/</span> <span class="n">rw</span>
        <span class="n">gx</span> <span class="o">=</span> <span class="n">gx</span> <span class="o">/</span> <span class="n">gw</span>
        <span class="n">gy</span> <span class="o">=</span> <span class="n">gy</span> <span class="o">/</span> <span class="n">gw</span>
        <span class="n">gz</span> <span class="o">=</span> <span class="n">gz</span> <span class="o">/</span> <span class="n">gw</span>
        <span class="n">bx</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">/</span> <span class="n">bw</span>
        <span class="n">by</span> <span class="o">=</span> <span class="n">by</span> <span class="o">/</span> <span class="n">bw</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="n">bz</span> <span class="o">/</span> <span class="n">bw</span>

        <span class="c1">## /* rgb of the desired point */</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ry</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">rz</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">gx</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gy</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gz</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">bx</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">by</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bz</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>

        <span class="n">rgblist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rgblist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">rgblist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">rgblist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="c1"># are there negative values?</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">rgblist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rgblist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgblist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">w</span>
            <span class="n">rgblist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgblist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">w</span>
            <span class="n">rgblist</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgblist</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">w</span>

        <span class="c1"># scale things so that max has value of 1</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">rgblist</span><span class="p">)</span>

        <span class="n">rgblist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgblist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mag</span>
        <span class="n">rgblist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgblist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mag</span>
        <span class="n">rgblist</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgblist</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">mag</span>

        <span class="c1"># rgb = {&#39;r&#39;: rgblist[0]/mag, &#39;g&#39;: rgblist[1]/mag, &#39;b&#39;: rgblist[2]/mag }</span>

        <span class="k">return</span> <span class="n">rgblist</span>

    <span class="k">def</span> <span class="nf">render_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">colorblindness</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="c1"># The grid of visible wavelengths corresponding to the grid of colour-matching</span>
        <span class="c1"># functions used by the ColourSystem instance.</span>

        <span class="c1"># Calculate the black body spectrum and the HTML hex RGB colour string</span>
        <span class="n">cierbg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rgb</span><span class="p">(</span><span class="n">colorblindness</span><span class="p">)</span>
        <span class="c1"># cierbg = [1.,0.427,0.713]</span>
        <span class="c1"># Place and label a circle with the colour of a black body at temperature T</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mf">1.2</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="n">cierbg</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">string</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mf">1.2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">cierbg</span>
        <span class="p">)</span>

        <span class="c1"># Set the limits and background colour; remove the ticks</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="c1"># ax.set_axis_bgcolor(&#39;k&#39;)</span>
        <span class="c1"># Make sure our circles are circular!</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compute_selective_mirror_fom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compute the figure of merit for selective tranmission and reflection according</span>
<span class="sd">           to the transmissive_envelope and reflective_envelope functions</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.transmissive_envelope : 1 x number_of_wavelength numpy array of floats </span>
<span class="sd">            the box funcion that spans the window where we want high transmissivity</span>

<span class="sd">        self.reflective_envelope : 1 x number_of_wavelength numpy array of floats </span>
<span class="sd">            the box function that spans the window where we want high reflectivity</span>

<span class="sd">        self.reflection_efficiency : float</span>
<span class="sd">            the first reflection fom: (int R(lambda) * reflective_envelope d lambda) / (int R(lambda) d lambda)</span>

<span class="sd">        self.reflection_selectivity : float</span>
<span class="sd">            the second reflection fom: (int R(lambda) * reflective_envelope d lambda) / (int reflective_envelope d lambda) </span>

<span class="sd">        self.transmission_efficiency : float</span>
<span class="sd">            the transmission fom: (int T(lambda) * transmissive_envelope d lambda) / (int tranmissive_envelope d lambda)</span>

<span class="sd">        self.selective_mirror_fom : float</span>
<span class="sd">            the composite figure of merit defined as f = a * transmission_efficiency + b * reflection_efficiency + c * reflection_selectivity</span>

<span class="sd">        self.transmission_efficiency_weight : float</span>
<span class="sd">            the weight of transmission efficiency in the composite figure of merit (a) satisfying a + b + c = 1</span>

<span class="sd">        self.reflection_efficiency_weight : float</span>
<span class="sd">            the weight of the reflection efficiency in the composite figure of merit (b) satisfying a + b + c = 1</span>

<span class="sd">        self.reflection_selectivity_weight : float</span>
<span class="sd">            the weight of the reflection selectivity in the composite figure of merit (c) satisfying a + b + c = 1</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># numerators come from the actual spectra times the envelope</span>
        <span class="n">_ut_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_envelope</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_array</span>
        <span class="n">_ur_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span>

        <span class="c1"># integrate to get numerators</span>
        <span class="n">_ut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">_ut_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>
        <span class="n">_ur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">_ur_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="c1"># denominators are slightly different between R and T.</span>

        <span class="c1"># T_denom -&gt; integrate transmissive envelope</span>
        <span class="n">_t_denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_envelope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>
        <span class="p">)</span>

        <span class="c1"># R_denom -&gt; integrate reflection spectrum</span>
        <span class="n">_r_denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>
        <span class="p">)</span>

        <span class="c1"># R_selective_denom -&gt; integrate the reflection envelope</span>
        <span class="n">_r_select_denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span> 
        <span class="p">)</span>

        <span class="c1"># if transmissivity_envelope is zero everywhere, this will give nan.. handle</span>
        <span class="c1"># by just giving value of zero the transmission_efficiency</span>

        <span class="k">if</span> <span class="n">_t_denom</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ut</span> <span class="o">/</span> <span class="n">_t_denom</span><span class="p">)</span>

        <span class="c1"># if reflectivity is zero everywhere, this will give nan - handle</span>
        <span class="c1"># by just giving value of zero to reflection_efficiency</span>
        
        <span class="k">if</span> <span class="n">_r_denom</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ur</span> <span class="o">/</span> <span class="n">_r_denom</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_r_select_denom</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ur</span> <span class="o">/</span> <span class="n">_r_select_denom</span><span class="p">)</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">selective_mirror_fom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_selective_mirror_fom_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compute the figure of merit for selective tranmission and reflection according</span>
<span class="sd">           to the transmissive_envelope and reflective_envelope functions</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        self.transmissive_envelope : 1 x number_of_wavelength numpy array of floats </span>
<span class="sd">            the box funcion that spans the window where we want high transmissivity</span>

<span class="sd">        self.reflective_envelope : 1 x number_of_wavelength numpy array of floats </span>
<span class="sd">            the box function that spans the window where we want high reflectivity</span>

<span class="sd">        self.reflection_efficiency : float</span>
<span class="sd">            the reflection fom: (int R(lambda) * reflective_envelope d lambda) / (int R(lambda) d lambda)</span>

<span class="sd">        self.transmission_efficiency : float</span>
<span class="sd">            the transmission fom: (int T(lambda) * transmissive_envelope d lambda) / (int tranmissive_envelope d lambda)</span>

<span class="sd">        self.selective_mirror_fom : float</span>
<span class="sd">            the composite figure of merit defined as f = a * transmission_efficiency + b * reflection_efficiency</span>

<span class="sd">        self.transmission_efficiency_weight : float</span>
<span class="sd">            the weight of transmission efficiency in the composite figure of merit (a) satisfying a + b = 1</span>

<span class="sd">        self.reflection_efficiency_weight : float</span>
<span class="sd">            the weight of the reflection efficiency in the composite figure of merit (b) satisfying a + b = 1</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        compute the figure of merit for selective tranmission and reflection according</span>
<span class="sd">        to the transmissive_envelope and reflective_envelope functions</span>

<span class="sd">        Working Equation</span>
<span class="sd">        ----------------</span>
<span class="sd">        useful_transmitted_power = int T(lambda) * transmission_envelope d lambda</span>

<span class="sd">        transmission_denom = int transmission_envelope( lambda) d lambda</span>

<span class="sd">        useful_reflected_power = int R(lambda) * reflection_envelope d lambda</span>

<span class="sd">        total_reflected_power = int R(lambda) d lambda</span>

<span class="sd">        eta_T&#39; = int T&#39;(lambda) * transmission_envelope d lambda / transmission_denom</span>

<span class="sd">        eta_R&#39; = g(lambda) f&#39;(lambda) - f(lambda) g&#39;(lambda)  / g(lambda) ^ 2</span>

<span class="sd">        where g(lambda) = int R(lambda) d lambda</span>
<span class="sd">              f(lambda) = int reflectivity_envelope R(lambda) d lambda</span>
<span class="sd">              g&#39;(lambda) = int R&#39;(lambda) dlambda</span>
<span class="sd">              f&#39;(lambda) = int reflectivity_envelope R&#39;(lambda) d lambda</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># eta_T&#39; = Pi(lambda) * T&#39;(lambda) / Pi(lambda)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_spectrum_gradient</span><span class="p">()</span>

        <span class="n">_ngr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># integrate the thermal emission spectrum over wavelength using np.trapz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_ngr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_ngr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_ngr</span><span class="p">)</span>

        <span class="c1"># this term is in the denominator of each of the eta_T&#39; elements</span>
        <span class="n">_eta_T_denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transmissive_envelope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="c1"># this term is in the denominator of each of the sel_R&#39; elements</span>
        <span class="n">_sel_R_denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="c1"># these terms are in each of the eta_R&#39; elements</span>
        <span class="n">_f_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>
        <span class="p">)</span>
        <span class="n">_g_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_ngr</span><span class="p">):</span>
            <span class="c1"># can compute eta_T&#39; in one shot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_gradient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transmissive_envelope</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmissivity_gradient_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">/</span> <span class="n">_eta_T_denom</span>
            <span class="p">)</span>
            <span class="c1"># can compute sel_R&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_gradient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span> 
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>
                <span class="p">)</span>
                <span class="o">/</span> <span class="n">_sel_R_denom</span>
            <span class="p">)</span>

            <span class="c1"># need to get parts of g&#39;(lambda) and f&#39;(lambda) terms</span>
            <span class="n">_gp_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span>
            <span class="p">)</span>
            <span class="n">_fp_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reflective_envelope</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflectivity_gradient_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_array</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_gradient</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_g_l</span> <span class="o">*</span> <span class="n">_fp_l</span> <span class="o">-</span> <span class="n">_f_l</span> <span class="o">*</span> <span class="n">_gp_l</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">_g_l</span><span class="o">**</span><span class="mi">2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selective_mirror_fom_gradient</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_efficiency_gradient</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_efficiency_gradient</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflection_selectivity_gradient</span>
        <span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Foley Lab. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.5.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>